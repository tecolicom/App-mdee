#!/usr/bin/env bash
# vim: filetype=bash :  -*- mode: sh; sh-shell: bash; -*-

set -euo pipefail

define() { IFS='\n' read -r -d '' ${1} || true ; }

myname="${0##*/}"

define pod <<"=cut"

=encoding utf-8

=head1 NAME

mdee - Markdown, Easy on the Eyes

=head1 SYNOPSIS

    mdee [ options ] file ...

     -h  --help             show help
         --version          show version
     -d  --debug            debug level (repeatable)
     -n  --dryrun           dry-run mode
         --[no-]fold        line folding (default: on)
         --[no-]table       table formatting (default: on)
         --[no-]nup         nup paged output (default: on)
     -w  --width=#          fold width (default: 80)
     -B  --base-color=#     base color (default: <NavyBlue>)
                            (e.g., <Red>, #FF5733, hsl(0,100,50))
     -C  --pane=#           number of columns
     -R  --row=#            number of rows
     -G  --grid=#           grid layout (e.g., 2x3)
     -P  --page=#           page height in lines
     -S  --pane-width=#     pane width (default: 85)
    --bs --border-style=#   border style
         --[no-]pager[=#]   pager command

=head1 VERSION

Version 0.01

=cut

[[ $pod =~ Version\ +([0-9.]+) ]] && my_version=${BASH_REMATCH[1]}

##############################################################################
# Utility functions
##############################################################################

die() {
    echo "$myname: $*" >&2
    exit 1
}

# Check bash version (4.3+ required for getoptlong.sh)
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3))); then
    die "bash 4.3+ required (found $BASH_VERSION)"
fi

##############################################################################
# Option definitions
##############################################################################

define USAGE <<END
mdee - Markdown, Easy on the Eyes

Usage: $myname [ options ] file ...
END

declare -a nup_opts=(--document --no-filename)

declare -A OPTS=(
    [&REQUIRE]=0.7 [&USAGE]="$USAGE"
    [         help | h   !         # show help         ]=
    [      version |     !         # show version      ]=
    [        debug | d   +         # debug level       ]=0
    [       dryrun | n             # dry-run mode      ]=
    [         fold |               # line folding      ]=1
    [        table |               # table formatting  ]=1
    [          nup |               # use nup           ]=1
    [        width | w  :=i        # fold width        ]=80
    [   base-color | B  :          # base color        ]='<NavyBlue>'
    [        pager |    ?!         # pager command     ]=
    [         grid | G  :>nup_opts # grid layout       ]=
    [         pane | C  :>nup_opts # number of columns ]=
    [          row | R  :>nup_opts # number of rows    ]=
    [         page | P  :>nup_opts # page height       ]=
    [   pane-width | S  :>nup_opts # pane width        ]=
    [ border-style | bs :>nup_opts # border style      ]=
)

##############################################################################
# Option callbacks
##############################################################################

help() {
    sed -E \
        -e '/^$/N' \
        -e 's/^(\n*)=head[0-9]* */\1/' \
        -e '/^\n*[#=]/d' \
        -e '/Version/q' \
        <<< "$pod"
    exit 0
}

version() {
    echo "$my_version"
    exit 0
}

pager() {
    if [[ -n $pager ]]; then
        nup_opts+=("--pager=$pager")
    else
        nup_opts+=("--no-pager")
    fi
}

##############################################################################
# Parse options
##############################################################################

. getoptlong.sh OPTS "$@"

##############################################################################
# Main
##############################################################################

if (( $# == 0 )) && [[ -t 0 ]]; then
    help
fi

##############################################################################
# Markdown highlighting with greple
##############################################################################

ITEM_PREFIX='^\h*(?:[*-]|\d+\.)\h+'

declare -a greple_opts=(-G --ci=G --all --need=0)

# Base color for headers
BASE=$base_color

# HTML comments (dimmed)
greple_opts+=(--cm "${BASE}+r60" -E '<!--.*?-->')

# Bold text
greple_opts+=(--cm "${BASE}D" -E '\*\*.*?\*\*')

# Headers (h1-h5)
greple_opts+=(
    --cm "L25DE/${BASE}"     -E '^#\h+.*'
    --cm "L25DE/${BASE}+l10" -E '^##\h+.*'
    --cm "L00DN/${BASE}=l93" -E '^###\h+.*'
    --cm "${BASE}UD"         -E '^####\h+.*'
    --cm "${BASE}+l20;U"     -E '^#####+.*'
)

# Inline code (backticks)
greple_opts+=(--cm '/L23,/L23,/L23' -E '(?<bt>`++)((?:(?!\g{bt}).)++)(\g{bt})')

# Code blocks (fenced)
greple_opts+=(
    --cm "L20 , ${BASE}=l85 , ${BASE}/L23;E , L20" \
    -E '^\h*(?<bt>`{3,}+)(.*)\n((?s:.*?))^\h*(\g{bt})'
)

##############################################################################
# Build command pipeline
##############################################################################

# Process files
if (( $# == 0 )); then
    # stdin mode (not supported yet)
    die "stdin mode not supported, please specify file(s)"
fi

# Define each command as an array
declare -a cmd_greple=(greple "${greple_opts[@]}" "$@")

declare -a cmd_fold=(
    greple
    -Mtee "&ansifold" --crmode --autoindent="$ITEM_PREFIX" -sw${width} --
    -E "${ITEM_PREFIX}.*\\n" --crmode --all --need=0 --no-color
)

declare -a cmd_table=(
    greple
    -Mtee::config=discrete "&ansicolumn" -s '|' -o '|' -t --cu=1 --
    -E '^(\|.+\|\n){3,}' --all --need=0 --no-color
)

declare -a cmd_table_fix=(
    perl -pE 's/ /-/g if /^ \| (\s* -+ \s* \|)+ $/x'
)

declare -a cmd_nup=(nup "${nup_opts[@]}")

# Collect pipeline stages
declare -a stages=(cmd_greple)
[[ $fold == 1 ]]  && stages+=(cmd_fold)
[[ $table == 1 ]] && stages+=(cmd_table cmd_table_fix)
[[ $nup == 1 ]]   && stages+=(cmd_nup)

# Build pipeline string from stages
quote_cmd() {
    printf '%q ' "$@"
}

pipeline=""
for stage in "${stages[@]}"; do
    declare -n cmd="$stage"
    [[ -n $pipeline ]] && pipeline+=" | "
    pipeline+="$(quote_cmd "${cmd[@]}")"
done

(( debug > 0 )) && echo "debug: stages: ${stages[*]}" >&2
(( debug > 0 )) && echo "debug: pipeline: $pipeline" >&2

if [[ ${dryrun:-} ]]; then
    echo "$pipeline"
else
    eval "$pipeline"
fi

: <<'=cut'

=head1 DESCRIPTION

B<mdee> is a Markdown viewer command that combines L<greple(1)> for
syntax highlighting with L<nup(1)> for multi-column paged output.

It provides colorized display of Markdown files with support for:

=over 4

=item * Headers (h1-h5) with distinct styling

=item * Bold text

=item * Inline code (backticks)

=item * Code blocks (fenced with ```)

=item * HTML comments (dimmed)

=item * Tables (formatted with ansicolumn)

=item * List items with proper indentation

=back

This tool is primarily designed for viewing Markdown files generated by
LLMs (Large Language Models), not for human-authored documents.  If you
need a polished viewer for hand-written Markdown, consider using a
dedicated Markdown viewer instead.

=head1 OPTIONS

=head2 General Options

=over 4

=item B<-h>, B<--help>

Show help message.

=item B<--version>

Show version.

=item B<-d>, B<--debug>

Set debug level.  Can be repeated (C<-d>, C<-dd>, C<-ddd>) for
increasing verbosity.

=item B<-n>, B<--dryrun>

Dry-run mode. Show the command without executing.

=back

=head2 Processing Options

=over 4

=item B<--[no-]fold>

Enable or disable line folding for list items.  When enabled, long
lines in list items are wrapped with proper indentation using
L<ansifold(1)>.  Default is enabled.

=item B<--[no-]table>

Enable or disable table formatting.  When enabled, Markdown tables
are formatted using L<ansicolumn(1)> for aligned column display.
Default is enabled.

=item B<--[no-]nup>

Enable or disable L<nup(1)> for multi-column paged output.  When
disabled, output goes directly to stdout without formatting.
Default is enabled.

=item B<-w> I<N>, B<--width>=I<N>

Set the fold width for text wrapping. Default is 80.
Only effective when C<--fold> is enabled.

=item B<-B> I<COLOR>, B<--base-color>=I<COLOR>

Set the base color for syntax highlighting.  Default is C<E<lt>NavyBlueE<gt>>.
Accepts L<Term::ANSIColor::Concise> color specifications:

=over 4

=item * Color names: C<E<lt>RedE<gt>>, C<E<lt>NavyBlueE<gt>>

=item * RGB hex: C<#FF5733>, C<FF5733>

=item * RGB decimal: C<rgb(255,87,51)>

=item * HSL: C<hsl(0,100,50)>

=back

B<Note:> Basic ANSI color codes (C<R>, C<G>, C<B>, etc.) are not supported
because the highlighting variations are created by adjusting lightness
of the base color, which requires full color specifications.

=back

=head2 Layout Options (passed to nup)

=over 4

=item B<-C> I<N>, B<--pane>=I<N>

Set the number of columns (panes).

=item B<-R> I<N>, B<--row>=I<N>

Set the number of rows.

=item B<-G> I<CxR>, B<--grid>=I<CxR>

Set grid layout. For example, C<-G2x3> creates 2 columns and 3 rows.

=item B<-P> I<N>, B<--page>=I<N>

Set the page height in lines.

=item B<-S> I<N>, B<--pane-width>=I<N>

Set the pane width in characters. Default is 85.

=item B<--bs>=I<STYLE>, B<--border-style>=I<STYLE>

Set the border style.

=back

=head2 Pager Options

=over 4

=item B<--[no-]pager>[=I<COMMAND>]

Set the pager command.  Use C<--pager> (without argument) or
C<--no-pager> to disable pager.

=back

=head1 EXAMPLES

    mdee README.md              # view markdown file
    mdee -C2 document.md        # 2-column view
    mdee -G2x2 manual.md        # 2x2 grid (4-up)
    mdee -w60 narrow.md         # narrower text width
    mdee --no-pager file.md     # without pager
    mdee --no-nup file.md       # output to stdout without nup
    mdee --no-fold file.md      # disable line folding
    mdee --no-table file.md     # disable table formatting

=head1 DEPENDENCIES

This command requires the following:

=over 4

=item * L<App::Greple> - pattern matching and highlighting

=item * L<App::Greple::tee> - filter integration

=item * L<App::ansifold> - ANSI-aware text folding

=item * L<App::ansicolumn> - ANSI-aware column formatting

=item * L<App::nup> - N-up multi-column paged output

=item * L<Getopt::Long::Bash> - bash option parsing

=back

=head1 SEE ALSO

L<nup(1)>, L<greple(1)>, L<ansifold(1)>, L<ansicolumn(1)>

=head1 AUTHOR

Kazumasa Utashiro

=head1 LICENSE

Copyright 2025-2026 Kazumasa Utashiro.

This software is released under the MIT License.
L<https://opensource.org/licenses/MIT>

=cut
