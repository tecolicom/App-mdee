#!/usr/bin/env bash
# vim: filetype=bash :  -*- mode: sh; sh-shell: bash; -*-

set -euo pipefail

define() { IFS='\n' read -r -d '' ${1} || true ; }

myname="${0##*/}"

define pod <<"=cut"

=encoding utf-8

=head1 NAME

mdee - Markdown, Easy on the Eyes

=head1 SYNOPSIS

    mdee [ options ] file ...

     -h  --help             show help
         --version          show version
     -d  --debug            debug level (repeatable)
     -n  --dryrun           dry-run mode
     -f  --filter           filter mode (highlight only)
         --[no-]fold        line folding (default: on)
         --[no-]table       table formatting (default: on)
         --[no-]nup         nup paged output (default: on)
     -w  --width=#          fold width (default: 80)
     -t  --theme=#          color theme
     -m  --mode=#           light or dark (default: light)
     -B  --base-color=#     override theme's base color
                            (e.g., <Red>, #FF5733, hsl(0,100,50))
         --list-themes      list built-in themes
     -C  --pane=#           number of columns
     -R  --row=#            number of rows
     -G  --grid=#           grid layout (e.g., 2x3)
     -P  --page=#           page height in lines
     -S  --pane-width=#     pane width (default: 85)
    --bs --border-style=#   border style
         --[no-]pager[=#]   pager command

=head1 VERSION

Version 0.01

=cut

[[ $pod =~ Version\ +([0-9.]+) ]] && my_version=${BASH_REMATCH[1]}

##############################################################################
# Utility functions
##############################################################################

die() {
    echo "$myname: $*" >&2
    exit 1
}

# Check bash version (4.3+ required for getoptlong.sh)
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 3))); then
    die "bash 4.3+ required (found $BASH_VERSION)"
fi

##############################################################################
# Option definitions
##############################################################################

define USAGE <<END
mdee - Markdown, Easy on the Eyes

Usage: $myname [ options ] file ...
END

declare -a nup_opts=(--document --no-filename)

declare -A OPTS=(
    [&REQUIRE]=0.7.1 [&USAGE]="$USAGE"
    [         help | h   !         # show help         ]=
    [      version |     !         # show version      ]=
    [        debug | d   +         # debug level       ]=0
    [       dryrun | n             # dry-run mode      ]=
    [       filter | f   !         # filter mode       ]=
    [         fold |               # line folding      ]=1
    [        table |               # table formatting  ]=1
    [          nup |               # use nup           ]=1
    [        width | w  :=i        # fold width        ]=80
    [        theme | t  :          # color theme       ]=default
    [         mode | m  :          # light or dark     ]=
    [   base-color | B  :          # base color        ]=
    [  list-themes |     !         # list themes       ]=
    [        pager |    ?!         # pager command     ]=
    [         grid | G  :>nup_opts # grid layout       ]=
    [         pane | C  :>nup_opts # number of columns ]=
    [          row | R  :>nup_opts # number of rows    ]=
    [         page | P  :>nup_opts # page height       ]=
    [   pane-width | S  :>nup_opts # pane width        ]=
    [ border-style | bs :>nup_opts # border style      ]=
)

##############################################################################
# Built-in themes
##############################################################################

declare -A theme_default_light=(
    [base]='<NavyBlue>'
    [comment]='${base}+r60'
    [bold]='${base}D'
    [strike]='X'
    [h1]='L25DE/${base}'
    [h2]='L25DE/${base}+l10'
    [h3]='L00DN/${base}=l93'
    [h4]='${base}UD'
    [h5]='${base}+l20;U'
    [inline_code]='/L23,/L23,/L23'
    [code_block]='L20 , L18 , ${base}/L23;E , L20'
)

declare -A theme_default_dark=(
    [base]='#CCCDFF'
    [comment]='${base}+r60'
    [bold]='${base}D'
    [strike]='X'
    [h1]='L00DE/${base}'
    [h2]='L00DE/${base}-l10'
    [h3]='L00DN/${base}-l15'
    [h4]='${base}UD'
    [h5]='${base}+l20;U'
    [inline_code]='/L05,/L05,/L05'
    [code_block]='L10 , L12 , ${base}/L05;E , L10'
)

# Active color scheme (initialized from light theme)
declare -A colors

##############################################################################
# Theme functions
##############################################################################

# Initialize colors from default light theme
init_theme() {
    for key in "${!theme_default_light[@]}"; do
        colors[$key]="${theme_default_light[$key]}"
    done
}

# Load a theme with mode
# Try theme_${name}_${mode} first, then theme_${name}
load_theme() {
    local name=$1
    local theme_mode=$2
    local theme_var="theme_${name}_${theme_mode}"

    # Try theme with mode first
    if declare -p "$theme_var" &>/dev/null; then
        local -n theme_ref="$theme_var"
        for key in "${!theme_ref[@]}"; do
            colors[$key]="${theme_ref[$key]}"
        done
        return 0
    fi

    # Fall back to theme without mode
    theme_var="theme_$name"
    if declare -p "$theme_var" &>/dev/null; then
        local -n theme_ref="$theme_var"
        for key in "${!theme_ref[@]}"; do
            colors[$key]="${theme_ref[$key]}"
        done
        return 0
    fi

    die "theme not found: $name"
}

# Load user config file
load_config() {
    local config_file="${XDG_CONFIG_HOME:-$HOME/.config}/mdee/config.sh"
    if [[ -f "$config_file" ]]; then
        . "$config_file"
    fi
}

# Detect mode from terminal background luminance
# Returns "dark" if luminance < 50, "light" otherwise
# Returns empty string if luminance cannot be determined
detect_terminal_mode() {
    local lum
    lum=$(perl -MGetopt::EX::termcolor=luminance -e luminance 2>/dev/null) || return
    [[ -z "$lum" ]] && return

    if (( lum < 50 )); then
        echo "dark"
    else
        echo "light"
    fi
}

# Expand ${base} references in color values
expand_theme() {
    local base="${colors[base]}"
    for key in "${!colors[@]}"; do
        if [[ "$key" != "base" ]]; then
            colors[$key]="${colors[$key]//\$\{base\}/$base}"
        fi
    done
}

##############################################################################
# Option callbacks
##############################################################################

help() {
    sed -E \
        -e '/^$/N' \
        -e 's/^(\n*)=head[0-9]* */\1/' \
        -e '/^\n*[#=]/d' \
        -e '/Version/q' \
        <<< "$pod"
    exit 0
}

version() {
    echo "$my_version"
    exit 0
}

pager() {
    if [[ -n $pager ]]; then
        nup_opts+=("--pager=$pager")
    else
        nup_opts+=("--no-pager")
    fi
}

filter() {
    fold=
    table=
    nup=
}

show_theme_sample() {
    local name=$1
    local theme_mode=$2
    local -A sample_colors
    local theme_var="theme_${name}_${theme_mode}"

    # Try theme with mode first, then without mode
    if declare -p "$theme_var" &>/dev/null; then
        local -n theme_ref="$theme_var"
        for key in "${!theme_ref[@]}"; do
            sample_colors[$key]="${theme_ref[$key]}"
        done
    else
        theme_var="theme_$name"
        if declare -p "$theme_var" &>/dev/null; then
            local -n theme_ref="$theme_var"
            for key in "${!theme_ref[@]}"; do
                sample_colors[$key]="${theme_ref[$key]}"
            done
        else
            return 1
        fi
    fi

    # Expand ${base}
    local base="${sample_colors[base]}"
    for key in "${!sample_colors[@]}"; do
        if [[ "$key" != "base" ]]; then
            sample_colors[$key]="${sample_colors[$key]//\$\{base\}/$base}"
        fi
    done

    # Show colored samples
    # Extract middle part of inline_code (format: before,match,after)
    local code_color="${sample_colors[inline_code]}"
    code_color="${code_color#*,}"  # remove before
    code_color="${code_color%,*}"  # remove after

    # Remove E (Erase Line) from color specs for sample display
    local h1="${sample_colors[h1]//E/}"
    local h2="${sample_colors[h2]//E/}"
    local h3="${sample_colors[h3]//E/}"

    local label="${name}/${theme_mode}"
    if [[ "$theme_mode" == "dark" ]]; then
        # Dark mode: show on dark background
        ansiecho -i 555/000E -f "  %-16s" "$label" \
                 " " -i "$h1" "# H1" -a 555/000 \
                 " " -i "$h2" "## H2" -a 555/000 \
                 " " -i "$h3" "### H3" -a 555/000 \
                 " " -i "${sample_colors[h4]}" "#### H4" -a 555/000 \
                 " " -i "${sample_colors[h5]}" "##### H5" -a 555/000 \
                 " " -i "${sample_colors[bold]}" "**bold**" -a 555/000 \
                 " " -i "${code_color}" '`code`' -a Z
    else
        # Light mode: show on light background
        ansiecho -i 000/555E -f "  %-16s" "$label" \
                 " " -i "$h1" "# H1" -a 000/555 \
                 " " -i "$h2" "## H2" -a 000/555 \
                 " " -i "$h3" "### H3" -a 000/555 \
                 " " -i "${sample_colors[h4]}" "#### H4" -a 000/555 \
                 " " -i "${sample_colors[h5]}" "##### H5" -a 000/555 \
                 " " -i "${sample_colors[bold]}" "**bold**" -a 000/555 \
                 " " -i "${code_color}" '`code`' -a Z
    fi
}

list_themes() {
    echo "Built-in themes:"
    show_theme_sample default light
    show_theme_sample default dark
    echo ""
    echo "Usage: mdee --mode=<light|dark> [--base-color=<color>]"
    echo ""
    echo "User config: \${XDG_CONFIG_HOME:-~/.config}/mdee/config.sh"
    echo "  default_mode='dark'        # set default mode"
    echo "  colors[base]='<Color>'     # override base color"
    exit 0
}

##############################################################################
# Parse options
##############################################################################

. getoptlong.sh OPTS "$@"

##############################################################################
# Main
##############################################################################

if (( $# == 0 )) && [[ -t 0 ]]; then
    help
fi

##############################################################################
# Theme setup
##############################################################################

# Initialize colors from default light theme
init_theme

# Load user config (may set default_theme and default_mode)
load_config

# Apply config defaults if options not specified
if [[ "$theme" == "default" && -n "${default_theme:-}" ]]; then
    theme="$default_theme"
fi
# Set mode: explicit option > config default > terminal detection > "light"
if [[ -z "$mode" ]]; then
    if [[ -n "${default_mode:-}" ]]; then
        mode="$default_mode"
    else
        mode=$(detect_terminal_mode)
        : ${mode:=light}
    fi
fi

# Load theme with mode
load_theme "$theme" "$mode"

# Override base color if specified
if [[ -n "$base_color" ]]; then
    colors[base]="$base_color"
fi

# Expand ${base} references in color values
expand_theme

(( debug > 0 )) && {
    echo "debug: color values:" >&2
    for key in "${!colors[@]}"; do
        echo "debug:   $key = ${colors[$key]}" >&2
    done
}

##############################################################################
# Markdown highlighting with greple
##############################################################################

declare -a greple_opts=(-G --ci=G --all --need=0)

# HTML comments (dimmed)
greple_opts+=(--cm "${colors[comment]}" -E '<!--.*?-->')

# Bold text
greple_opts+=(--cm "${colors[bold]}" -E '\*\*.*?\*\*')

# Strikethrough
greple_opts+=(--cm "${colors[strike]}" -E '~~.+?~~')

# Headers (h1-h5)
greple_opts+=(
    --cm "${colors[h1]}" -E '^#\h+.*'
    --cm "${colors[h2]}" -E '^##\h+.*'
    --cm "${colors[h3]}" -E '^###\h+.*'
    --cm "${colors[h4]}" -E '^####\h+.*'
    --cm "${colors[h5]}" -E '^#####+.*'
)

# Inline code (backticks)
greple_opts+=(--cm "${colors[inline_code]}" -E '(?<bt>`++)((?:(?!\g{bt}).)++)(\g{bt})')

# Code blocks (fenced)
greple_opts+=(
    --cm "${colors[code_block]}" \
    -E '^\h*(?<bt>`{3,}+)(.*)\n((?s:.*?))^\h*(\g{bt})'
)

##############################################################################
# Build command pipeline
##############################################################################

# Process files
if (( $# == 0 )); then
    if [[ ! ${filter:-} ]]; then
        die "stdin mode not supported without -f option"
    fi
else
    # Check if all files exist
    for file in "$@"; do
        [[ -e "$file" ]] || die "$file: No such file or directory"
    done
fi

# Define each command as an array
declare -a cmd_greple=(greple "${greple_opts[@]}" "$@")

ITEM_PREFIX='^\h*(?:[*-]|\d+\.)\h+'
DEF_PATTERN='(?:\A|\G\n|\n\n).+\n\n?(:\h+.*\n)'
AUTOINDENT='^\h*(?:[*-]|\d+\.|:)\h+'

declare -a cmd_fold=(
    greple
    -Mtee "&ansifold" --crmode --autoindent="$AUTOINDENT" -sw${width} --
    -G -E "${ITEM_PREFIX}.*\\n" -E "${DEF_PATTERN}"
    --crmode --all --need=0 --no-color
)

declare -a cmd_table=(
    greple
    -Mtee::config=discrete "&ansicolumn" -s '|' -o '|' -t --cu=1 --
    -E '^(\|.+\|\n){3,}' --all --need=0 --no-color
)

declare -a cmd_table_fix=(
    perl -pE 's/ /-/g if /^ \| (\s* -+ \s* \|)+ $/x'
)

declare -a cmd_nup=(nup "${nup_opts[@]}")

# Collect pipeline stages
declare -a stages=(cmd_greple)
[[ $fold == 1 ]]  && stages+=(cmd_fold)
[[ $table == 1 ]] && stages+=(cmd_table cmd_table_fix)
[[ $nup == 1 ]]   && stages+=(cmd_nup)

# Build pipeline string from stages
pipeline=""
for stage in "${stages[@]}"; do
    declare -n cmd="$stage"
    [[ -n $pipeline ]] && pipeline+=" | "
    pipeline+="$(printf '%q ' "${cmd[@]}")"
done

(( debug > 0 )) && echo "debug: stages: ${stages[*]}" >&2
(( debug > 0 )) && echo "debug: pipeline: $pipeline" >&2

if [[ ${dryrun:-} ]]; then
    echo "$pipeline"
else
    eval "$pipeline"
fi

: <<'=cut'

=head1 DESCRIPTION

B<mdee> is a Markdown viewer command that combines L<greple(1)> for
syntax highlighting with L<nup(1)> for multi-column paged output.

It provides colorized display of Markdown files with support for:

=over 4

=item * Headers (h1-h5) with distinct styling

=item * Bold text

=item * Inline code (backticks)

=item * Code blocks (fenced with ```)

=item * HTML comments (dimmed)

=item * Tables (formatted with ansicolumn)

=item * List items with proper indentation

=back

This tool is primarily designed for viewing Markdown files generated by
LLMs (Large Language Models), not for human-authored documents.  If you
need a polished viewer for hand-written Markdown, consider using a
dedicated Markdown viewer instead.

=head1 OPTIONS

=head2 General Options

=over 4

=item B<-h>, B<--help>

Show help message.

=item B<--version>

Show version.

=item B<-d>, B<--debug>

Set debug level.  Can be repeated (C<-d>, C<-dd>, C<-ddd>) for
increasing verbosity.

=item B<-n>, B<--dryrun>

Dry-run mode. Show the command without executing.

=item B<-f>, B<--filter>

Filter mode.  Reads from stdin (or files) and outputs highlighted
Markdown to stdout.  Disables line folding, table formatting, and
nup paged output.  Useful for piping Markdown content through mdee
for syntax highlighting only.

=back

=head2 Processing Options

=over 4

=item B<--[no-]fold>

Enable or disable line folding for list items.  When enabled, long
lines in list items are wrapped with proper indentation using
L<ansifold(1)>.  Default is enabled.

=item B<--[no-]table>

Enable or disable table formatting.  When enabled, Markdown tables
are formatted using L<ansicolumn(1)> for aligned column display.
Default is enabled.

=item B<--[no-]nup>

Enable or disable L<nup(1)> for multi-column paged output.  When
disabled, output goes directly to stdout without formatting.
Default is enabled.

=item B<-w> I<N>, B<--width>=I<N>

Set the fold width for text wrapping. Default is 80.
Only effective when C<--fold> is enabled.

=back

=head2 Theme Options

B<mdee> supports color themes for customizing syntax highlighting.
Themes define colors for various Markdown elements (headers, code blocks,
bold text, etc.).

=over 4

=item B<-t> I<NAME>, B<--theme>=I<NAME>

Select a color theme.  Default is C<default>.

=item B<-m> I<MODE>, B<--mode>=I<MODE>

Select light or dark mode.  Default is C<light>.

If the terminal supports background color detection (via
L<Getopt::EX::termcolor>), the mode is automatically selected based on
terminal luminance.

Each theme has light and dark variants optimized for different terminal
backgrounds.  The built-in C<default> theme provides:

=over 4

=item C<light> - Navy blue base color for light backgrounds

=item C<dark> - Light blue (#CCCDFF) base color for dark backgrounds

=back

User configuration is loaded from:

    ${XDG_CONFIG_HOME:-~/.config}/mdee/config.sh

This is a shell script that can set defaults and override colors:

    # ~/.config/mdee/config.sh
    default_mode='dark'              # set default mode
    colors[base]='<DarkCyan>'        # override base color
    colors[h1]='L25DE/${base}'       # header with base background

Color specifications use L<Term::ANSIColor::Concise> format.
The C<FG/BG> notation specifies foreground and background colors
(e.g., C<L25DE/${base}> means gray foreground on base-colored background).
The C<${base}> string is expanded to the base color value after loading.

=item B<-B> I<COLOR>, B<--base-color>=I<COLOR>

Override the theme's base color.  This is useful for quickly adjusting
the color scheme without creating a custom theme.
Accepts L<Term::ANSIColor::Concise> color specifications:

=over 4

=item * Color names: C<E<lt>RedE<gt>>, C<E<lt>NavyBlueE<gt>>

=item * RGB hex: C<#FF5733>

=item * RGB decimal: C<rgb(255,87,51)>

=item * HSL: C<hsl(0,100,50)>

=back

B<Note:> Basic ANSI color codes (C<R>, C<G>, C<B>, etc.) are not supported
because the highlighting variations are created by adjusting lightness
of the base color, which requires full color specifications.

=item B<--list-themes>

List built-in themes with color samples and exit.

=back

=head2 Layout Options (passed to nup)

=over 4

=item B<-C> I<N>, B<--pane>=I<N>

Set the number of columns (panes).

=item B<-R> I<N>, B<--row>=I<N>

Set the number of rows.

=item B<-G> I<CxR>, B<--grid>=I<CxR>

Set grid layout. For example, C<-G2x3> creates 2 columns and 3 rows.

=item B<-P> I<N>, B<--page>=I<N>

Set the page height in lines.

=item B<-S> I<N>, B<--pane-width>=I<N>

Set the pane width in characters. Default is 85.

=item B<--bs>=I<STYLE>, B<--border-style>=I<STYLE>

Set the border style.

=back

=head2 Pager Options

=over 4

=item B<--[no-]pager>[=I<COMMAND>]

Set the pager command.  Use C<--pager> (without argument) or
C<--no-pager> to disable pager.

=back

=head1 EXAMPLES

    mdee README.md              # view markdown file
    mdee -C2 document.md        # 2-column view
    mdee -G2x2 manual.md        # 2x2 grid (4-up)
    mdee -w60 narrow.md         # narrower text width
    mdee --no-pager file.md     # without pager
    mdee --no-nup file.md       # output to stdout without nup
    mdee --no-fold file.md      # disable line folding
    mdee --no-table file.md     # disable table formatting

    # Filter mode
    cat file.md | mdee -f       # highlight stdin
    mdee -f file.md             # highlight only (no paging)

    # Theme examples
    mdee --mode=dark file.md             # use dark mode
    mdee --mode=light file.md            # use light mode
    mdee -B '<Red>' file.md              # override base color
    mdee --mode=dark -B '<Cyan>' file.md # dark mode with cyan base
    mdee --list-themes                   # list available themes

=head1 DEPENDENCIES

This command requires the following:

=over 4

=item * L<App::Greple> - pattern matching and highlighting

=item * L<App::Greple::tee> - filter integration

=item * L<App::ansifold> - ANSI-aware text folding

=item * L<App::ansicolumn> - ANSI-aware column formatting

=item * L<App::nup> - N-up multi-column paged output

=item * L<App::ansiecho> - ANSI color output

=item * L<Getopt::Long::Bash> - bash option parsing

=item * L<Getopt::EX::termcolor> - terminal background detection

=back

=head1 IMPLEMENTATION

B<mdee> is implemented as a Bash script that orchestrates multiple
specialized tools into a unified pipeline.  The architecture follows
Unix philosophy: each tool does one thing well, and they communicate
through standard streams.

The overall data flow is:

    Input File
        |
        v
    [greple] --- Syntax Highlighting
        |
        v
    [ansifold] --- Text Folding (optional)
        |
        v
    [ansicolumn] --- Table Formatting (optional)
        |
        v
    [nup] --- Paged Output (optional)
        |
        v
    Terminal/Pager

=head2 Pipeline Architecture

B<mdee> dynamically constructs a pipeline based on enabled options.
Each stage is represented as a Bash array containing the command and
its arguments.  The `--dryrun` option displays the constructed pipeline
without execution.

=head3 Processing Stages

The pipeline consists of four configurable stages.  Each stage can be
enabled or disabled independently using `--[no-]fold`, `--[no-]table`,
and `--[no-]nup` options.

=head4 Syntax Highlighting

The first stage uses L<greple(1)> with the `-G` (grep mode) and
`--ci=G` (capture index) options to apply different colors to each
captured group in regular expressions.

Supported Markdown elements:

- Headers (`# h1` through `##### h5`)
- Bold text (`**bold**`)
- Inline code (`` `code` ``)
- Code blocks (``` fenced ```)
- HTML comments (`<!-- comment -->`)

=head5 Color Specifications

Colors are specified using L<Term::ANSIColor::Concise> format.
The `--cm` option maps colors to captured groups.  For example,
`L00DE/${base}` specifies gray foreground on base-colored background.

The color specification supports modifiers:

- `+l10` / `-l10`: Adjust lightness by percentage
- `=l50`: Set absolute lightness
- `D`: Bold, `U`: Underline, `E`: Erase line

Example greple invocation:

    greple -G --ci=G --all --need=0 \
        --cm 'L00DE/${base}' -E '^#\h+.*' \
        --cm '${base}D' -E '\*\*.*?\*\*' \
        file.md

=head4 Text Folding

The second stage wraps long lines in list items using L<ansifold(1)>
via L<Greple::tee>.  It preserves ANSI escape sequences and maintains
proper indentation for nested lists.

The folding width is controlled by `--width` option (default: 80).

=head4 Table Formatting

The third stage formats Markdown tables using L<ansicolumn(1)>.
Tables are detected by the pattern `^(\|.+\|\n){3,}` and formatted
with aligned columns while preserving ANSI colors.

=head3 Output Stage

The final stage uses L<nup(1)> to provide multi-column paged output.
Layout options (`--pane`, `--row`, `--grid`, `--page`) are passed
directly to nup.

=head2 Theme System

B<mdee> implements a theme system with light and dark mode variants.

=head3 Theme Structure

Each theme is defined as a Bash associative array with color
definitions for each Markdown element:

    declare -A theme_default_dark=(
        [base]='#CCCDFF'
        [h1]='L00DE/${base}'
        [h2]='L00DE/${base}-l10'
        ...
    )

=head4 Base Color Expansion

The `${base}` placeholder in color values is expanded after theme
loading.  This allows derived colors to be calculated from a single
base color, making theme customization easier.

=head4 Terminal Mode Detection

B<mdee> uses L<Getopt::EX::termcolor> to detect terminal background
luminance.  If luminance is below 50%, dark mode is automatically
selected.

=head1 SEE ALSO

L<nup(1)>, L<greple(1)>, L<ansifold(1)>, L<ansicolumn(1)>

=head1 AUTHOR

Kazumasa Utashiro

=head1 LICENSE

Copyright 2026 Kazumasa Utashiro.

This software is released under the MIT License.
L<https://opensource.org/licenses/MIT>

=cut
